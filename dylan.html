<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nuclear Fusion Visualiser</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --panel2:#0f1630;
      --text:#e9ecff;
      --muted:#a7b0d6;
      --accent:#7aa7ff;
      --good:#55e3a3;
      --warn:#ffd166;
      --bad:#ff5c7a;
      --border:rgba(255,255,255,.10);
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background: radial-gradient(1000px 600px at 20% 10%, rgba(122,167,255,.18), transparent 55%),
                  radial-gradient(900px 700px at 90% 30%, rgba(85,227,163,.14), transparent 55%),
                  radial-gradient(900px 700px at 50% 95%, rgba(255,92,122,.10), transparent 55%),
                  var(--bg);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    .app{
      width:min(1100px, 100%);
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:18px;
    }
    @media (max-width: 950px){
      .app{ grid-template-columns: 1fr; }
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .side{
      padding:18px 18px 14px;
      background: linear-gradient(180deg, rgba(18,26,51,.92), rgba(15,22,48,.92));
    }
    h1{
      margin:0 0 8px;
      font-size:20px;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0 0 14px;
      color:var(--muted);
      line-height:1.35;
      font-size:13px;
    }
    .group{
      padding:12px;
      background: rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius: 14px;
      margin-bottom:12px;
    }
    .row{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      margin-bottom:8px;
    }
    .label{
      font-size:13px;
      color:var(--muted);
    }
    .value{
      font-family:var(--mono);
      font-size:13px;
      color:var(--text);
    }
    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }
    .hint{
      margin-top:6px;
      color:rgba(233,236,255,.75);
      font-size:12px;
      line-height:1.35;
    }
    .kpis{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
      margin-top:12px;
    }
    .kpi{
      padding:12px;
      background: rgba(0,0,0,.18);
      border:1px solid var(--border);
      border-radius: 14px;
    }
    .kpi .klabel{
      font-size:12px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .kpi .kvalue{
      font-family:var(--mono);
      font-size:16px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      color:var(--muted);
      padding:8px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background: rgba(0,0,0,.18);
      margin-top:10px;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background: var(--warn);
      box-shadow: 0 0 14px rgba(255,209,102,.65);
    }
    .dot.good{ background: var(--good); box-shadow: 0 0 14px rgba(85,227,163,.55); }
    .dot.bad{ background: var(--bad); box-shadow: 0 0 14px rgba(255,92,122,.55); }

    .main{
      position:relative;
      background: linear-gradient(180deg, rgba(18,26,51,.78), rgba(15,22,48,.78));
      min-height: 540px;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }
    .overlay{
      position:absolute;
      inset:14px 14px auto 14px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      pointer-events:none;
      flex-wrap:wrap;
    }
    .badge{
      pointer-events:none;
      background: rgba(0,0,0,.28);
      border:1px solid var(--border);
      border-radius: 999px;
      padding:8px 10px;
      font-size:12px;
      color:rgba(233,236,255,.85);
      font-family: var(--mono);
    }
    .footer{
      margin-top:10px;
      font-size:12px;
      color:rgba(233,236,255,.55);
      line-height:1.35;
    }
    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card side">
      <h1>Nuclear Fusion Visualiser</h1>
      <p class="subtitle">
        Adjust plasma parameters and watch a simplified D-T plasma. The animation is illustrative (not a reactor simulator),
        but the <b>triple product</b> is calculated exactly as <span style="font-family:var(--mono)">n·T·τ</span>.
      </p>

      <div class="group">
        <div class="row">
          <div class="label">Temperature, T</div>
          <div class="value"><span id="tOut"></span> keV</div>
        </div>
        <input id="t" type="range" min="1" max="50" step="0.5" value="15" />
        <div class="hint">Higher T -> faster ions + higher fusion reactivity (peaks broadly around tens of keV for D-T).</div>
      </div>

      <div class="group">
        <div class="row">
          <div class="label">Density, n</div>
          <div class="value"><span id="nOut"></span> m^-3</div>
        </div>
        <input id="n" type="range" min="0.1" max="5" step="0.1" value="1.0" />
        <div class="hint">Visual particle count scales with n. Fusion rate scales ~ n^2 (more collisions).</div>
      </div>

      <div class="group">
        <div class="row">
          <div class="label">Confinement time, τ</div>
          <div class="value"><span id="tauOut"></span> s</div>
        </div>
        <input id="tau" type="range" min="0.01" max="10" step="0.01" value="1.0" />
        <div class="hint">Longer τ -> energy stays in the plasma longer; visually fewer "loss" events.</div>
      </div>

      <div class="kpis">
        <div class="kpi">
          <div class="klabel">Fusion triple product (n·T·τ)</div>
          <div class="kvalue"><span id="tpOut"></span> keV·s·m^-3</div>
        </div>
        <div class="kpi">
          <div class="klabel">Toy D-T reactivity (for visuals)</div>
          <div class="kvalue"><span id="svOut"></span> m^3/s</div>
        </div>
        <div class="kpi">
          <div class="klabel">Relative fusion power (visual scale)</div>
          <div class="kvalue"><span id="pOut"></span></div>
        </div>
      </div>

      <div class="pill">
        <span class="dot" id="statusDot"></span>
        <span id="statusText">Adjust sliders to explore regimes</span>
      </div>

      <div class="footer">
        Tip: put this file in a GitHub repo as <span style="font-family:var(--mono)">index.html</span>, then enable
        <b>Settings -> Pages -> Deploy from branch</b>.
      </div>
    </div>

    <div class="card main">
      <div class="overlay">
        <div class="badge" id="badgeLeft"></div>
        <div class="badge" id="badgeRight"></div>
      </div>
      <canvas id="c"></canvas>
    </div>
  </div>

<script>
(() => {
  // -----------------------------
  // UI + parameter model
  // -----------------------------
  const elT = document.getElementById('t');
  const elN = document.getElementById('n');
  const elTau = document.getElementById('tau');

  const tOut = document.getElementById('tOut');
  const nOut = document.getElementById('nOut');
  const tauOut = document.getElementById('tauOut');

  const tpOut = document.getElementById('tpOut');
  const svOut = document.getElementById('svOut');
  const pOut = document.getElementById('pOut');

  const badgeLeft = document.getElementById('badgeLeft');
  const badgeRight = document.getElementById('badgeRight');

  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');

  // Density slider is in units of (x10^20 m^-3) to keep the UI friendly:
  // n = nSlider * 1e20 m^-3
  function getParams(){
    const T_keV = Number(elT.value);
    const n_1e20 = Number(elN.value);
    const n = n_1e20 * 1e20; // m^-3
    const tau = Number(elTau.value); // s
    return { T_keV, n_1e20, n, tau };
  }

  // Toy D-T reactivity curve (m^3/s) shaped to respond to temperature:
  // - This is NOT a precise Bosch-Hale fit.
  // - It's a smooth curve that rises with T and broadly peaks in the tens of keV.
  function sigmaV_DT_toy(T_keV){
    // A log-normal-ish bump, with a mild high-T falloff:
    const x = Math.log(Math.max(T_keV, 0.2));
    const mu = Math.log(15);      // centre ~ 15 keV
    const s  = 0.75;              // width
    const bump = Math.exp(-0.5 * ((x - mu)/s)**2);

    // Scale to plausible order of magnitude around 1e-22 to 1e-21 m^3/s.
    // Add a small baseline so it isn't zero at low T.
    const base = 2.0e-24;
    const peak = 1.6e-21;
    const fall = 1 / (1 + (T_keV/80)**1.5);
    return base + peak * bump * fall;
  }

  // Triple product in keV·s·m^-3 (since T is in keV).
  function tripleProduct(n, T_keV, tau){
    return n * T_keV * tau;
  }

  // A soft "status" indicator based on triple product relative to a typical Lawson-ish scale.
  // For D-T ignition, often-quoted order ~ 3e21 keV·s·m^-3 (varies with assumptions).
  const LAWSON_REF = 3e21;

  function formatSI(x, digits=3){
    if (!isFinite(x)) return "—";
    const abs = Math.abs(x);
    if (abs === 0) return "0";
    const exp = Math.floor(Math.log10(abs));
    const mant = x / 10**exp;
    return `${mant.toFixed(digits)}e${exp}`;
  }

  function formatInt(x){
    return x.toLocaleString('en-GB');
  }

  // -----------------------------
  // Canvas simulation
  // -----------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  function resize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
  }
  window.addEventListener('resize', resize);
  resize();

  // Particles represent ions in a 2D box with reflecting walls.
  // Speed scales ~ sqrt(T). Particle count scales with density.
  // Confinement time affects loss probability (particles leaving / energy loss).
  const ions = [];
  const flashes = [];
  let last = performance.now();

  function rand(min, max){ return min + Math.random()*(max-min); }
  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

  function spawnIon(w, h, speed){
    const angle = rand(0, Math.PI*2);
    return {
      x: rand(20, w-20),
      y: rand(20, h-20),
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed,
      r: rand(1.6, 2.4),
      // two colours for "D" and "T" ions (roughly)
      type: Math.random() < 0.5 ? 0 : 1
    };
  }

  function ensureIonCount(target){
    // Smoothly adjust to target
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    while (ions.length < target){
      ions.push(spawnIon(w, h, 50));
    }
    while (ions.length > target){
      ions.pop();
    }
  }

  function addFlash(x, y, strength){
    flashes.push({ x, y, t:0, life: rand(0.18, 0.35), s: strength });
  }

  function drawBackground(w, h){
    // Subtle grid + vignette
    ctx.clearRect(0,0,w,h);

    ctx.save();
    // grid
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = "#cdd6ff";
    ctx.lineWidth = 1;
    const step = 36;
    for(let x=0; x<w; x+=step){
      ctx.beginPath();
      ctx.moveTo(x,0); ctx.lineTo(x,h);
      ctx.stroke();
    }
    for(let y=0; y<h; y+=step){
      ctx.beginPath();
      ctx.moveTo(0,y); ctx.lineTo(w,y);
      ctx.stroke();
    }
    ctx.restore();

    // vignette
    const g = ctx.createRadialGradient(w*0.5,h*0.5, Math.min(w,h)*0.15, w*0.5,h*0.5, Math.min(w,h)*0.75);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.40)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function stepSim(dt, params){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    // Ion count maps density to something reasonable for the screen.
    // n range: 0.1..5 x 1e20 -> map to ~120..520 ions.
    const targetCount = Math.round(90 + params.n_1e20 * 85);
    ensureIonCount(targetCount);

    // speed scale ~ sqrt(T)
    const speedBase = 25 + 7.5 * Math.sqrt(params.T_keV); // px/s
    // Confinement time influences "loss" probability per second
    const lossPerSecond = 0.45 / Math.max(params.tau, 0.01); // higher tau => less loss
    const lossProb = clamp(lossPerSecond * dt, 0, 0.15);

    // Fusion probability per close encounter depends on toy reactivity and density.
    // We'll convert it into a per-collision chance that "feels right" visually.
    const sv = sigmaV_DT_toy(params.T_keV); // m^3/s
    // Scale factor to map physical-looking numbers to screen events:
    const fusionScale = 2.5e21; // purely for visual tuning
    const fusionBias = clamp((params.n / 1e20) * (sv * fusionScale), 0, 0.35);

    // Update ions
    for (let i=0; i<ions.length; i++){
      const p = ions[i];

      // random loss/reinjection (represents particle/energy losses)
      if (Math.random() < lossProb){
        const np = spawnIon(w, h, speedBase);
        ions[i] = np;
        continue;
      }

      // gently steer velocities toward speedBase
      const v = Math.hypot(p.vx, p.vy) || 1;
      const desired = speedBase;
      const k = 0.10;
      p.vx += (p.vx / v) * (desired - v) * k * dt;
      p.vy += (p.vy / v) * (desired - v) * k * dt;

      p.x += p.vx * dt;
      p.y += p.vy * dt;

      // bounce walls
      if (p.x < p.r){ p.x = p.r; p.vx *= -1; }
      if (p.x > w - p.r){ p.x = w - p.r; p.vx *= -1; }
      if (p.y < p.r){ p.y = p.r; p.vy *= -1; }
      if (p.y > h - p.r){ p.y = h - p.r; p.vy *= -1; }
    }

    // Collisions + fusion flashes (naive O(N^2) but ok at a few hundred)
    for (let i=0; i<ions.length; i++){
      for (let j=i+1; j<ions.length; j++){
        const a = ions[i], b = ions[j];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx,dy);
        const minD = a.r + b.r + 0.8;
        if (dist > 0 && dist < minD){
          // elastic-ish bounce
          const nx = dx / dist;
          const ny = dy / dist;

          const relvx = b.vx - a.vx;
          const relvy = b.vy - a.vy;
          const sep = relvx*nx + relvy*ny;

          if (sep < 0){
            const impulse = -sep * 0.95;
            a.vx -= impulse * nx;
            a.vy -= impulse * ny;
            b.vx += impulse * nx;
            b.vy += impulse * ny;
          }

          // fusion chance: higher if types differ (D+T) and with fusionBias
          const isDT = (a.type !== b.type);
          const chance = fusionBias * (isDT ? 1.0 : 0.25);

          if (Math.random() < chance){
            const fx = (a.x + b.x)/2;
            const fy = (a.y + b.y)/2;
            addFlash(fx, fy, isDT ? 1.0 : 0.6);

            // after "fusion", replace the two ions with fresh ones (represents consumption + new ions)
            ions[i] = spawnIon(w, h, speedBase);
            ions[j] = spawnIon(w, h, speedBase);
          }
        }
      }
    }

    // Update flashes
    for (let k=flashes.length-1; k>=0; k--){
      const f = flashes[k];
      f.t += dt;
      if (f.t > f.life) flashes.splice(k,1);
    }
  }

  function draw(params){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    drawBackground(w,h);

    // Draw "magnetic bottle" boundary
    ctx.save();
    ctx.globalAlpha = 0.70;
    ctx.strokeStyle = "rgba(122,167,255,0.55)";
    ctx.lineWidth = 2;
    ctx.setLineDash([10,10]);
    ctx.beginPath();
    ctx.roundRect(18,18,w-36,h-36,24);
    ctx.stroke();
    ctx.restore();

    // Flashes first (glow)
    for (const f of flashes){
      const a = 1 - (f.t / f.life);
      const r = 10 + 40*(1-a)*f.s;
      const grad = ctx.createRadialGradient(f.x,f.y, 0, f.x,f.y, r);
      grad.addColorStop(0, `rgba(255, 245, 200, ${0.85*a})`);
      grad.addColorStop(0.35, `rgba(255, 209, 102, ${0.45*a})`);
      grad.addColorStop(1, `rgba(255, 92, 122, 0)`);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(f.x,f.y,r,0,Math.PI*2);
      ctx.fill();
    }

    // Ions
    for (const p of ions){
      ctx.save();
      const isD = (p.type === 0);

      // Slightly different hues
      ctx.fillStyle = isD ? "rgba(122, 167, 255, 0.85)" : "rgba(85, 227, 163, 0.85)";
      ctx.shadowBlur = 12;
      ctx.shadowColor = isD ? "rgba(122,167,255,0.55)" : "rgba(85,227,163,0.45)";
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // Add a soft "heat haze" overlay depending on T
    ctx.save();
    const haze = clamp((params.T_keV - 1) / 49, 0, 1) * 0.18;
    ctx.globalAlpha = haze;
    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0, "rgba(255,92,122,0.18)");
    g.addColorStop(1, "rgba(122,167,255,0.18)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  // -----------------------------
  // Main loop + UI updates
  // -----------------------------
  function updateUI(params){
    tOut.textContent = params.T_keV.toFixed(1);
    nOut.textContent = `${params.n_1e20.toFixed(1)}x10^20`;
    tauOut.textContent = params.tau.toFixed(2);

    const tp = tripleProduct(params.n, params.T_keV, params.tau); // keV s m^-3
    tpOut.textContent = formatSI(tp, 3);

    const sv = sigmaV_DT_toy(params.T_keV);
    svOut.textContent = formatSI(sv, 2);

    // Relative fusion power ~ n^2 * <σv> * (some tau influence for "stored energy")
    const rel = (params.n_1e20**2) * (sv / 1e-22) * (0.35 + 0.65*clamp(params.tau/3, 0, 1));
    const relClamped = Math.max(0, rel);
    pOut.textContent = `${relClamped.toFixed(2)} x (arb.)`;

    // Status based on triple product fraction of a reference
    const frac = tp / LAWSON_REF;
    let msg = "Sub-critical (explore higher n, T, or τ)";
    let cls = "bad";

    if (frac > 0.1) { msg = "Approaching Lawson-like territory (illustrative)"; cls = "warn"; }
    if (frac > 0.4) { msg = "High triple product (illustrative)"; cls = "good"; }

    statusText.textContent = msg;
    statusDot.classList.remove('good','bad');
    statusDot.classList.add(cls === "good" ? "good" : (cls === "bad" ? "bad" : ""));

    // Badges
    const T_K = params.T_keV * 1.16045e7; // 1 keV ~ 1.16045e7 K
    badgeLeft.textContent = `T ≈ ${formatSI(T_K, 2)} K  |  n ≈ ${formatSI(params.n, 2)} m^-3`;
    badgeRight.textContent = `τ = ${params.tau.toFixed(2)} s  |  nTτ ≈ ${formatSI(tp, 2)} keV·s·m^-3`;
  }

  function tick(now){
    const dt = Math.min(0.033, (now - last)/1000); // clamp to 33 ms
    last = now;

    const params = getParams();
    updateUI(params);
    stepSim(dt, params);
    draw(params);

    requestAnimationFrame(tick);
  }

  function onInput(){
    // No heavy work needed; loop reads live values.
  }

  elT.addEventListener('input', onInput);
  elN.addEventListener('input', onInput);
  elTau.addEventListener('input', onInput);

  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
